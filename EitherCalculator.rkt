#lang racket
(require data/either)
(require data/monad)
(define-struct stack-return (value stack))

;Create a stack return value for the stack.
(define (create-stack-return value stack)
  (make-stack-return value stack)
  )


;Pop the top of the stack.
(define (pop stack)
  (create-stack-return (last stack) (reverse (rest (reverse stack))))
  )

;Pops from the stack only if there is something left to pop.
(define (safe-pop stack)
  (if (empty? stack)(failure "Not enough on stack for operation")
      (success (pop stack))
      )
  )

;Safely divide two numbers.
(define (safe-divide a b)
  (if (zero? b)
      (failure "dividing by zero is not possible")
      (success (/ a b)))
  )

;Safely divide two numbers from the stack.
(define (divide-two stack)
  (do [b <- (safe-pop stack)]
    [a <- (safe-pop (stack-return-stack b))]
    [result <- (safe-divide (stack-return-value a) (stack-return-value b))]
    (append (stack-return-stack a) (list result))
    )
  )

;Handles addition, multiplaction, and substraction depending on what you pass it.
(define (safe-math stack f)
  (do [a <- (safe-pop stack)]
      [b <- (safe-pop (stack-return-stack a))]
    (append (stack-return-stack b) (list (f (stack-return-value b) (stack-return-value a))))
  )
  )

;Add an element onto the stack.
(define (push stack elem)
  (append stack (list elem))
  )

;Clear the stack
(define (clear)
  '()
  )

;Show the current state of the stack.
(define (show stack)
  (println stack)
  )

;Show the top of the stack.
(define (top stack)
  (println (last stack))
  )

;Show the size of the stack.
(define (size stack)
  (println (length stack))
  )

;Duplicate the first? item of the stack.
(define (duplicate stack)
  (if (empty? stack)
      (exit 0)
  (append stack (list (first stack))))
  )

(define (main)
  ;Read input
  (define a (read-line (current-input-port) 'any))
  
  ;Our list of valid user commands.
  (define valid-commands '("+" "-" "*" "/" "CLR" "SHOW" "TOP" "SIZ" "DUP" "END"))

  ;Read any valid input, otherwise quit.
  (define (safe-input input)
    (if (or (member input valid-commands) (string->number input))
        (success input)
        (failure "Not a valid input")
        )
    )

  ;Safely check that the list is not empty.
  (define (safe-first lst)
    (if (empty? lst)
        (failure "empty list")
        (success (first lst))
        )
    )

  ;Accept input from the user.
  (define (accept-input usrinput stack)
    (define parsed-input (chain safe-input (safe-first (string-split usrinput))))
    
    ;End the current evaluation with reasoning.
    (define (end issue)
      (fprintf (current-output-port)"Error: ~s\nStack: "
           issue)
      (show usrinput)
      (exit 0)
      )

    ;Continue on success.
    (define (continue input)
      ;Perform the operation the user specified.
      (define (perform-op operation)
        (cond
        [(string=? operation "+") (safe-math stack +)]
        [(string=? operation "-") (safe-math stack -)]
        [(string=? operation "*") (safe-math stack *)]
        [(string=? operation "/") (divide-two stack)]
        [(string=? operation "END") (exit 0)]
        [(string=? operation "SHOW") (show stack) stack]
        [(string=? operation "CLR") (clear)]
        [(string=? operation "TOP") (top stack) stack]
        [(string=? operation "SIZ") (size stack) stack]
        [(string=? operation "DUP") (duplicate stack)]
        [(push stack (string->number operation))]
        
        )
        )
      (define new-stack (perform-op input))

      ;Handle any failures generated by performing the operation.
      (if (failure? new-stack)
          (end (from-failure #f new-stack))
          null
          )

      ;Successfully continue with taking user input.
      (if (not (empty? (rest (string-split usrinput))))
        (accept-input (string-join (rest (string-split usrinput)) " ") new-stack)
        (accept-input (read-line (current-input-port) 'any) new-stack)
        ) 
      )
    (either end continue parsed-input)  
   )
  (accept-input a '())
  )

(main)